# 싱글톤 패턴

---

### [정의]

- 인스턴스를 오직 한개만 제공하는 클래스
- 시스템 런타임, 환경 세팅에 대한 정보 등, 인스턴스가 여러개일 때 문제가 생길 수 있는 경우가 있다. 인스턴스를 오직 한개만 만들어 제공하는 클래스가 필요하다.

### [가장 간단한 구현 방법]

**private 생성자에 static 메서드**

- 생성자가 private하기 때문에, global하게 접근할 수 있는(static) 메서드를 만들어줘야한다.
- 멀티스레드 환경에서 안전하지 못하다.
- if문 평가시에 동시에 서로 다른 스레드가 접근하여 instance를 생성하려고 시도할 수 있다.
- private 생성자를 가지고 있기 때문에, 상속을 받지 못한다.

### [Thread safe 이슈를 고려한 방법]

**synchronized 키워드 사용**

- private 생성자에 synchronized 키워드를 사용하여 동기화 시켜준다.
- 동기화를 해줘야하는 작업이 있기 때문에 성능상에 이슈가 있다.
  - lock을 얻고, 해제하는 과정이 추가되기 때문
- 클래스 lock을 사용한다.

**이른 초기화(Eager initailization)을 이용하는 방법**

- final 키워드를 사용
- 클래스가 로딩되는 시점에, static으로 선언된 필드가 초기화될 때, 인스턴스를 생성해두는 방법
- synchronized 키워드를 사용하지 않아도 동기화 이슈가 없다.

**주의** : instance를 만들 때, 리소스를 많이 사용하는 경우, 사용하지 않는다면 메모리 이슈가 있을 수 있다.

### [Thread safe를 고려하며 성능을 고려하는 방법]

**double check locking 사용**

- double check locking으로 효율적인 동기화 블럭 생성하여 lazy하게 대응할 수 있음
- 특정 스레드가 synchronized 블럭에 먼저 접근한 경우, 동기화 문제가 발생하지 않음
- getInstance() 메서드를 호출할 때 마다 synchronized 키워드를 만나지 않기 때문에, 성능상에 효율성도 챙길 수 있다.
  - 하지만 volatile 키워드를 객체 필드에 선언해줘야한다. - [link](https://parkcheolu.tistory.com/16) 참조, 가시성 문제를 해결한다.
    - CPU Cache 메모리와 RAM 데이터가 일치하지 않는 문제를 volatile 키워드를 사용하여 RAM에서 바로 읽도록 지정할 수 있다.
    - 1.5 버전 이상을 사용해야한다.

**static inner 클래스를 사용하는 방법**

- 멀티 스레드 환경에서도 안전하고,lazy loading(정확하게 말하면 initialization) 가능해진다.
  - static inner 클래스는 호출 시점에 클래스가 초기화되기 때문
- 클래스 로딩과 초기화 시점이 다름을 명심하자

### [싱글톤 패턴을 파훼법]

**reflection 사용**

- 리플랙션을 사용하여 직접 바이코드를 이용해 객체를 생성하는 경우, 상기 소개했던 방법들을 파훼할 수 있음
- 대응 방안이 딱히 없다.

**직렬화, 역직렬화 사용**

- Settings가 serializable 인터페이스를 구현한 경우, 사용 가능
- readResolve() 메서드를 override하여 우리가 의도한 getInstance를 호출하도록 변경해준다면 방지 가능

### [파훼법 막아보기]

**Enum 사용**

- reflect에서 enum에 대한 리플렉션을 막아놨다.
- 직렬화, 역직렬화 또한 막아놨다.
- 하지만, 클래스 로딩 시점에 초기화가 되어 lazy하지 못하다.
  - 엄밀히 말하자면, enum은 클래스 로딩 시점에 만들어지니까 지연 초기화가 아니다.
- 객체 생성 과정만이 thread safe한거지, 필드들은 아니다.
- 상속을 지원하지 않는다.

### [실무에서 어떻게 사용할까?]

- java.lang.Runtime에서 사용
  - thread safe
- 자바 어플리케이션이 실행되는 환경에 대한 정보 접근 가능
- Spring에서 Bean의 스코프중 하나로 사용
- 다른 디자인 패턴(빌더, 퍼사드, 추상 팩토리등)의 구현체의 일부

## 강의노트 질문 모음

---

### [가장 단순한 구현 방법]

**생성자를 private으로 만든 이유**

- 외부에서 생성자를 통한 객체 생성을 막기 위함

**getInstance() 메서드를 static으로 선언한 이유**

- global하게 접근할 수 있도록 접근 메서드를 뚫어주고, 생성자에 대한 접근을 막기 위해

**getInstance() 메서드가 thread safe하지 않은 이유**

- 동시에 두 쓰레드가 instance를 check하는 경우, unsafe하다.

### [멀티 쓰레드 환경을 고려한 방법]

**자바의 동기화 블럭 처리 방법**

- synchronized 키워드를 메서드에 사용하여 하나의 쓰레드만 접근하게함

**getInstance 메서드 동기화 시, 사용하는 lock은 인스턴스의 락인가 클래스의 락인가?**


- 클래스 락 사용

**이른 초기화가 단점이 될 수 있는 이유?**

- 지연 초기화를 사용하지 않기 때문에, 필요한 시점이 아님에도 리소스를 사용한다.

**만약 생성자에서 checked 예외를 던진다면 어떻게 이를 catch할까?**

- static 메서드로 wrapping하고, 해당 메서드에서 catch한다.

**double check locking이라고 부르는 이유**

- synchronized 블럭 안에 if문이 한번더 있기 때문

**double check locking에서 instance 변수는 어떻게 정의해야하는가? 그 이유는?**

- volatile 키워드를 사용해서 가시성을 확보해줘야한다. 그렇지 않다면, CPU Cache에 instance 변수의 내용이 저장되고, 다른 쓰레드간 각각의 CPU cache에서 읽어오기 때문에 가시성이 확보되지 않을 수 있다.

**static inner클래스 사용 시, static final임에도 왜 지연 초기화라고 볼 수 있는가?**

- static inner 클래스는 outer class 로딩 시, 로딩되지만, inner class의 내부 필드들에 대해서는 호출시점에 초기화되기 때문이다.

### [싱글톤 파훼하기]

**리플랙션에 대해 설명해보기**

- 클래스 로딩 내용을 바탕으로 메서드 정보나 필드 정보등을 접근할 수 있도록 자바에서 제공하는 api

**setAccessible(true)를 사용하는 이유는?**

- private으로 접근 제한자가 지정되어 있기 때문

**자바의 직렬화, 역직렬화에 대해서 설명하기**

- 직렬화 : 내부에서 사용되는 객체나 Data를 외부 자바 프로그램에서도 사용할 수 있도록 byte 형태로 변환하는 기술
- 역직렬화 : byte 형태로 기술되어있는 data나 객체를 다시 객체나 data화 하는것

**Seriailizable Id란 무엇이며 왜 쓰는가?**

- Serializable을 상속받는 경우, 클래스의 버전 관리를 위해 serialVersionUID를 사용하게 된다.
- 해당 변수를 명시적으로 선언해주지 않으면 컴파일러가 계산한 값을 임의로 부여하게 되는데, 해당 클래스 또는 Outter class에 변경이 있으면 UID를 변경하게 된다.
- 만약 직렬화 또는 역직렬화 시점에 UID가 다르다면 InvalidClassExceptions가 발생하여 저장된 값을 객체 또는 data로 재변환할 수 없다.

**try-resource 블럭에 대해서 설명하기**

- 기존 try-catch-final에서 보완한 것
- resource 해제 로직이 내재되어있는것

### [파훼법 막아보기]

**Enum 타입의 인스턴스를 리플렉션을 통해 만들 수 있는가?**

- 리플랙션 api 자체에서 Enum 타입의 객체에 대한 접근을 막아두어 불가능하다.

**Enum으로 싱글톤 타입을 구현할 때의 단점은?**

- 인스턴스를 미리 생성해두기 때문에 호출시점에 생성하기 어렵다.
- 상속이 불가능하다.

**직렬화 & 역직렬화시에 별도로 구현해야하는 메서드가 있는가?**

- Enum은 기본적으로 안전장치를 마련하지 않아도 직렬화, 역직렬화시에 싱글톤이 파훼되지 않는다.

### [복습]

**자바에서 enum을 사용하지 않고, 싱글톤 패턴을 구현하는 방법은?**

- private 생성자와 static 메서드를 사용하는 방법
  - inner 클래스
  - double check locking with synchronized

**private 생성자와 static 메서드를 사용하는 방법의 단점은?**

- 상속받지 못한다.
- thread safe하게 만드는 과정이 복잡하다.

**enum을 사용해 싱글톤 패턴을 구현하는 방법의 장점과 단점은?**

- 장점
  - 파훼법에 대해서 안전하다.
  - 객체 생성 과정이 thread safe하다.
- 단점
  - 객체가 로딩시점에 생성된다는 점
  - 상속을 받을 수 없다는 점

**static inner 클래스를 사용해 싱글톤 패턴을 구현해보기**