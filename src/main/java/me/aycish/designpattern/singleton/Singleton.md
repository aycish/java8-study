# 싱글톤 패턴

---

### [정의]

- 인스턴스를 오직 한개만 제공하는 클래스
- 시스템 런타임, 환경 세팅에 대한 정보 등, 인스턴스가 여러개일 때 문제가 생길 수 있는 경우가 있다. 인스턴스를 오직 한개만 만들어 제공하는 클래스가 필요하다.

### [구현 방법]

**private 생성자에 static 메서드**
- 생성자가 private하기 때문에, global하게 접근할 수 있는(static) 메서드를 만들어줘야한다.
- 멀티스레드 환경에서 안전하지 못하다.
  - if문 평가시에 동시에 서로 다른 스레드가 접근하여 instance를 생성하려고 시도할 수 있다.
- private 생성자를 가지고 있기 때문에, 상속을 받지 못한다.

### [동기화 이슈를 고려한 경우]

**synchronized 키워드 사용**
- private 생성자에 synchronized 키워드를 사용하여 동기화 시켜준다.
- 동기화를 해줘야하는 작업이 있기 때문에 성능상에 이슈가 있다.
  - lock을 얻고, 해제하는 과정이 추가되기 때문

**이른 초기화(Eager initailization)을 이용하는 방법**
- final 키워드를 사용
- 클래스가 로딩되는 시점에, static으로 선언된 필드가 초기화될 때, 인스턴스를 생성해두는 방법
- synchronized 키워드를 사용하지 않아도 동기화 이슈가 없다. 

**주의** : instance를 만들 때, 리소스를 많이 사용하는 경우, 사용하지 않는다면 메모리 이슈가 있을 수 있다.

### [동기화를 고려하며 메모리를 고려하는 경우]

**double checked locking 사용**
- double checked locking으로 효율적인 동기화 블럭 생성하여 lazy하게 대응할 수 있음
- 특정 스레드가 synchronized 블럭에 먼저 접근한 경우, 동기화 문제가 발생하지 않음
- getInstance() 메서드를 호출할 때 마다 synchronized 키워드를 만나지 않기 때문에, 성능상에 효율성도 챙길 수 있다.
- 하지만 volatile 키워드를 객체 필드에 선언해줘야한다.
  - 1.5 버전 이상을 사용해야한다.

**static inner 클래스를 사용하는 방법**
- 멀티 스레드 환경에서도 안전하고,lazy loading(정확하게 말하면 initialization) 가능해진다.
  - static inner 클래스는 호출 시점에 클래스가 초기화되기 때문
  - 클래스 로딩과 초기화 시점이 다름을 명심하자